@{
    ViewData["Title"] = "Dashboard";
}

<div class="app-header">
    <div class="header-left">
        <span class="status-dot"></span>
        <span class="app-title">STREAM | Dashboard</span>
        <nav class="menu-items">
            <button class="menu-item" id="menuFile">File</button>
            <button class="menu-item" id="menuConnection">Connection</button>
            <button class="menu-item" id="menuAnalytics">Analytics</button>
            <button class="menu-item" id="menuSettings">Settings</button>
            <button class="menu-item" id="menuExit">Exit</button>
        </nav>
    </div>
    <div class="header-right">
        <div class="clock-container">
            <span class="clock-icon">🕒</span>
            <span id="headerClock"></span>
        </div>
    </div>
    
</div>

<div class="dashboard-container">
    <div class="left-section">
        <div id="no-cameras" class="no-cameras">
            <div class="no-cameras-container">
                <div class="no-cameras-icon">📷</div>
                <div class="no-cameras-text">No camera available</div>
                <div class="no-cameras-subtext">Click Connection menu to add a camera</div>
            </div>
        </div>
        <div class="location-section" id="section-1">
            <div class="panel-header">
                <div class="panel-title">BINAG (Bohol)</div>
                <div class="panel-lastupdate">Last Update: <span id="lu-1">--</span></div>
                <div class="panel-actions">
                    <button class="btn-actions" data-actions="1">Actions ▾</button>
                    <div class="dropdown-menu" id="menu-1">
                        <button class="dropdown-item" data-action="reconnect" data-section="1">🔄 Reconnect</button>
                        <button class="dropdown-item" data-action="actions" data-section="1">🧰 Actions</button>
                        <button class="dropdown-item" data-action="configure" data-section="1">⚙ Configure</button>
                        <button class="dropdown-item" data-action="capture" data-section="1">📸 Capture</button>
                        <div class="dropdown-sep"></div>
                        <button class="dropdown-item" data-action="demo" data-section="1">🎬 Demo</button>
                        <button class="dropdown-item delete-item" data-action="delete" data-section="1">🗑 Delete Camera</button>
                    </div>
                </div>
            </div>
            <div class="camera-analytics-row" id="row-1">
                <div class="camera-feed">
                    <div class="no-signal" id="camera1-nosignal">
                        <span class="no-signal-text">No Signal</span>
                    </div>
                    <img src="" alt="Camera 1 Original" id="camera1-original" class="camera-img">
                </div>
                <div class="camera-feed">
                    <div class="no-signal" id="camera1-ai-nosignal">
                        <span class="no-signal-text">No Signal</span>
                    </div>
                    <img src="" alt="Camera 1 AI" id="camera1-ai" class="camera-img">
                    <canvas id="det1" class="det-overlay"></canvas>
                    <!-- Gauge overlay for Camera 1 (right side) -->
                    <div class="gauge-overlay" id="gauge1">
                        <div class="gauge-scale">
                            <span>90</span>
                            <span>80</span>
                            <span>70</span>
                            <span>60</span>
                            <span>50</span>
                            <span>40</span>
                            <span>30</span>
                            <span>20</span>
                            <span>10</span>
                        </div>
                        <div class="gauge-bar">
                            <div class="gauge-fill" id="gauge1-fill" style="height: 10%"></div>
                        </div>
                    </div>
                </div>
                <div class="analytics-section compact">
                    <div class="analytics-header-compact">
                        <label for="hr-1">Hour Range</label>
                        <select id="hr-1" class="hour-range-select">
                            <option>4</option>
                            <option>6</option>
                            <option selected>8</option>
                            <option>12</option>
                            <option>24</option>
                        </select>
                    </div>
                    <canvas id="analytics1"></canvas>
                </div>
            </div>
        </div>

        <div class="location-section" id="section-2">
            <div class="panel-header">
                <div class="panel-title">San Vicente (Bohol)</div>
                <div class="panel-lastupdate">Last Update: <span id="lu-2">--</span></div>
                <div class="panel-actions">
                    <button class="btn-actions" data-actions="2">Actions ▾</button>
                    <div class="dropdown-menu" id="menu-2">
                        <button class="dropdown-item" data-action="reconnect" data-section="2">🔄 Reconnect</button>
                        <button class="dropdown-item" data-action="actions" data-section="2">🧰 Actions</button>
                        <button class="dropdown-item" data-action="configure" data-section="2">⚙ Configure</button>
                        <button class="dropdown-item" data-action="capture" data-section="2">📸 Capture</button>
                        <div class="dropdown-sep"></div>
                        <button class="dropdown-item" data-action="demo" data-section="2">🎬 Demo</button>
                        <button class="dropdown-item delete-item" data-action="delete" data-section="2">🗑 Delete Camera</button>
                    </div>
                </div>
            </div>
            <div class="camera-analytics-row" id="row-2">
                <div class="camera-feed">
                    <div class="no-signal" id="camera2-nosignal">
                        <span class="no-signal-text">No Signal</span>
                    </div>
                    <img src="" alt="Camera 2 Original" id="camera2-original" class="camera-img">
                </div>
                <div class="camera-feed">
                    <div class="no-signal" id="camera2-ai-nosignal">
                        <span class="no-signal-text">No Signal</span>
                    </div>
                    <img src="" alt="Camera 2 AI" id="camera2-ai" class="camera-img">
                    <canvas id="det2" class="det-overlay"></canvas>
                    <!-- Gauge overlay for Camera 2 (right side) -->
                    <div class="gauge-overlay" id="gauge2">
                        <div class="gauge-scale">
                            <span>90</span>
                            <span>80</span>
                            <span>70</span>
                            <span>60</span>
                            <span>50</span>
                            <span>40</span>
                            <span>30</span>
                            <span>20</span>
                            <span>10</span>
                        </div>
                        <div class="gauge-bar">
                            <div class="gauge-fill" id="gauge2-fill" style="height: 10%"></div>
                        </div>
                    </div>
                </div>
                <div class="analytics-section compact">
                    <div class="analytics-header-compact">
                        <label for="hr-2">Hour Range</label>
                        <select id="hr-2" class="hour-range-select">
                            <option>4</option>
                            <option>6</option>
                            <option selected>8</option>
                            <option>12</option>
                            <option>24</option>
                        </select>
                    </div>
                    <canvas id="analytics2"></canvas>
                </div>
            </div>
        </div>

        <div class="location-section" id="section-3">
            <div class="panel-header">
                <div class="panel-title">Bandahug (Bohol)</div>
                <div class="panel-lastupdate">Last Update: <span id="lu-3">--</span></div>
                <div class="panel-actions">
                    <button class="btn-actions" data-actions="3">Actions ▾</button>
                    <div class="dropdown-menu" id="menu-3">
                        <button class="dropdown-item" data-action="reconnect" data-section="3">🔄 Reconnect</button>
                        <button class="dropdown-item" data-action="actions" data-section="3">🧰 Actions</button>
                        <button class="dropdown-item" data-action="configure" data-section="3">⚙ Configure</button>
                        <button class="dropdown-item" data-action="capture" data-section="3">📸 Capture</button>
                        <div class="dropdown-sep"></div>
                        <button class="dropdown-item" data-action="demo" data-section="3">🎬 Demo</button>
                        <button class="dropdown-item delete-item" data-action="delete" data-section="3">🗑 Delete Camera</button>
                    </div>
                </div>
            </div>
            <div class="camera-analytics-row" id="row-3">
                <div class="camera-feed">
                    <div class="no-signal" id="camera3-nosignal">
                        <span class="no-signal-text">No Signal</span>
                    </div>
                    <img src="" alt="Camera 3 Original" id="camera3-original" class="camera-img">
                </div>
                <div class="camera-feed">
                    <div class="no-signal" id="camera3-ai-nosignal">
                        <span class="no-signal-text">No Signal</span>
                    </div>
                    <img src="" alt="Camera 3 AI" id="camera3-ai" class="camera-img">
                    <canvas id="det3" class="det-overlay"></canvas>
                    <!-- Gauge overlay for Camera 3 (right side) -->
                    <div class="gauge-overlay" id="gauge3">
                        <div class="gauge-scale">
                            <span>90</span>
                            <span>80</span>
                            <span>70</span>
                            <span>60</span>
                            <span>50</span>
                            <span>40</span>
                            <span>30</span>
                            <span>20</span>
                            <span>10</span>
                        </div>
                        <div class="gauge-bar">
                            <div class="gauge-fill" id="gauge3-fill" style="height: 10%"></div>
                        </div>
                    </div>
                </div>
                <div class="analytics-section compact">
                    <div class="analytics-header-compact">
                        <label for="hr-3">Hour Range</label>
                        <select id="hr-3" class="hour-range-select">
                            <option>4</option>
                            <option>6</option>
                            <option selected>8</option>
                            <option>12</option>
                            <option>24</option>
                        </select>
                    </div>
                    <canvas id="analytics3"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="right-section">
        <div class="map-status-header">
            <div class="flooding-status">
                <div class="flood-badge">--</div>
                <span class="flood-na">N/A</span>
            </div>
            <div class="status-legend">
                <div class="legend-item flooding">
                    <span class="legend-dot"></span>
                    <span class="legend-text">Flooding</span>
                </div>
                <div class="legend-item high">
                    <span class="legend-dot"></span>
                    <span class="legend-text">High</span>
                </div>
                <div class="legend-item normal-yellow">
                    <span class="legend-dot"></span>
                    <span class="legend-text">Normal</span>
                </div>
                <div class="legend-item normal-green">
                    <span class="legend-dot"></span>
                    <span class="legend-text">Normal</span>
                </div>
            </div>
        </div>
        <div id="map"></div>
    </div>
<!-- Connections Modal (Add Camera) -->
<div id="connectionModal" class="modal-overlay hidden">
    <div class="modal-card addcam-modal">
        <div class="modal-header">
            <div class="modal-header-left">
                <span class="status-dot"></></span>
                <span class="modal-title">STREAM | Add Camera</span>
            </div>
            <button class="btn-close" id="connClose" aria-label="Close">×</button>
        </div>
        <div class="modal-toolbar">
            <button type="button" class="tool-btn" id="btnAddCamera">📷 Add Camera</button>
            <button type="button" class="tool-btn" id="btnClear">🧹 Clear</button>
        </div>
        <div class="addcam-body">
            <div class="preview-pane"><div class="preview-video" id="connPreview"></div></div>
            <div class="config-pane">
                <div class="group-box"><div class="group-title">Configuration</div></div>
                <div class="subgroup">
                    <div class="sub-title">Camera</div>
                    <label>IP Address <span class="req">*</span></label>
                    <input id="ipAddress" class="form-input" placeholder="e.g. 192.168.1.100" />
                    <label>Port</label>
                    <input id="port" class="form-input" placeholder="e.g. 554" />
                    <label>Channel</label>
                    <input id="channel" class="form-input" value="Streaming/Channels/101" />
                    <label>Username</label>
                    <input id="username" class="form-input" />
                    <label>Password</label>
                    <input id="password" type="password" class="form-input" />
                </div>
                <div class="subgroup">
                    <div class="sub-title">Location</div>
                    <label>Name <span class="req">*</span></label>
                    <input id="locName" class="form-input" />
                    <label>Latitude <span class="req">*</span></label>
                    <input id="latitude" class="form-input" />
                    <label>Longitude <span class="req">*</span></label>
                    <div class="inline">
                        <input id="longitude" class="form-input" />
                        <button type="button" class="btn small" id="btnMap">Map</button>
                    </div>
                </div>
                <div class="player-controls">
                    <button type="button" class="btn green" id="btnPlay">Play</button>
                    <button type="button" class="btn" id="btnStop">Stop</button>
                </div>
                <div class="helper-text">Enter the RTSP stream URL of your camera to view and test the live feed. Once entered, press PLAY to begin streaming.</div>
            </div>
        </div>
        <div class="status-bar">
            <span id="connStatus">RTSP Camera Started: —</span>
            <div class="progress"><div class="progress-fill" id="connProgress"></div></div>
        </div>
    </div>
    <div class="modal-backdrop"></div>
</div>

<!-- Map Picker Modal -->
<div id="mapPicker" class="map-picker-overlay hidden">
    <div class="map-picker-card">
        <div class="map-picker-header"><div>Pick Location</div><button class="btn-close" id="pickerClose">×</button></div>
        <div class="map-picker-body"><div id="pickerMap" class="map-picker-map"></div><div class="crosshair"></div></div>
        <div class="map-picker-footer">
            <div class="picker-controls">
                <label>Radius (m):</label>
                <input id="pickerRadius" class="input-small" type="number" value="200" min="10" step="10" />
                <button class="btn btn-sm" id="pickerCircle">Circle</button>
                <button class="btn btn-sm" id="pickerPolygon">Polygon</button>
                <button class="btn btn-sm" id="pickerAutoCover">Auto Cover</button>
                <button class="btn btn-sm" id="pickerClear">Clear</button>
            </div>
            <div class="picker-controls">
                <input id="pickerLat" class="input-small" placeholder="lat" />
                <input id="pickerLng" class="input-small" placeholder="lng" />
                <button class="btn green btn-sm" id="pickerUse">Use</button>
            </div>
        </div>
    </div>
    <div class="map-picker-backdrop"></div>
</div>

<!-- Configure Camera Modal -->
<div id="configureModal" class="modal-overlay hidden">
    <div class="modal-card addcam-modal">
        <div class="modal-header">
            <div class="modal-header-left">
                <span class="status-dot"></span>
                <span class="modal-title">STREAM | Configure Camera</span>
            </div>
            <button class="btn-close" id="configureClose" aria-label="Close">×</button>
        </div>
        <div class="addcam-body">
            <div class="config-pane">
                <div class="group-box"><div class="group-title">Camera Configuration</div></div>
                <div class="subgroup">
                    <div class="sub-title">Camera</div>
                    <label>IP Address <span class="req">*</span></label>
                    <input id="configIpAddress" class="form-input" placeholder="e.g. 192.168.1.100" />
                    <label>Port</label>
                    <input id="configPort" class="form-input" placeholder="e.g. 554" />
                    <label>Channel</label>
                    <input id="configChannel" class="form-input" value="Streaming/Channels/101" />
                    <label>Username</label>
                    <input id="configUsername" class="form-input" />
                    <label>Password</label>
                    <input id="configPassword" type="password" class="form-input" />
                </div>
                <div class="subgroup">
                    <div class="sub-title">Location</div>
                    <label>Name <span class="req">*</span></label>
                    <input id="configLocName" class="form-input" />
                    <label>Latitude <span class="req">*</span></label>
                    <input id="configLatitude" class="form-input" />
                    <label>Longitude <span class="req">*</span></label>
                    <div class="inline">
                        <input id="configLongitude" class="form-input" />
                        <button type="button" class="btn small" id="configBtnMap">Map</button>
                    </div>
                </div>
                <div class="player-controls">
                    <button type="button" class="btn green" id="configSave">Save</button>
                    <button type="button" class="btn" id="configCancel">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    <div class="modal-backdrop"></div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="modal-overlay hidden">
    <div class="modal-card settings-modal">
        <div class="modal-header">
            <div class="modal-header-left">
                <span class="status-dot"></span>
                <span class="modal-title">STREAM | Settings</span>
            </div>
            <button class="btn-close" id="settingsClose" aria-label="Close">×</button>
        </div>
        
        <!-- Settings Tabs -->
        <div class="settings-tabs">
            <button class="tab-btn active" data-tab="general">General</button>
            <button class="tab-btn" data-tab="roboflow">AI Model</button>
            <button class="tab-btn" data-tab="system">System</button>
        </div>
        
        <!-- Tab Content -->
        <div class="settings-content">
            <!-- General Tab -->
            <div class="tab-content active" id="general-tab">
                <div class="settings-section">
                    <h4>Application Settings</h4>
                    <div class="setting-group">
                        <label>Auto-refresh interval (seconds):</label>
                        <input type="number" id="refreshInterval" value="30" min="5" max="300">
                    </div>
                    <div class="setting-group">
                        <label>Detection confidence threshold:</label>
                        <input type="range" id="confidenceThreshold" min="0" max="1" step="0.1" value="0.5">
                        <span id="confidenceValue">0.5</span>
                    </div>
                    <div class="setting-group">
                        <label>
                            <input type="checkbox" id="enableNotifications" checked>
                            Enable flood alerts
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- Roboflow Tab -->
            <div class="tab-content" id="roboflow-tab">
                <div class="settings-section">
                    <div class="roboflow-header">
                        <h4>🤖 Roboflow AI Model</h4>
                        <span class="roboflow-project">Project: stream-cw7hj</span>
                    </div>
                    
                    <div class="roboflow-stats">
                        <div class="stat-card">
                            <div class="stat-label">Images</div>
                            <div class="stat-value" id="roboflow-images">--</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Versions</div>
                            <div class="stat-value" id="roboflow-versions">--</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Classes</div>
                            <div class="stat-value" id="roboflow-classes">--</div>
                        </div>
                    </div>
                    
                    <div class="roboflow-actions">
                        <button class="btn-action primary" id="btnLoadProject">
                            <span>🔄</span> Load Project
                        </button>
                        <button class="btn-action secondary" id="btnDownloadDataset">
                            <span>📥</span> Download Dataset
                        </button>
                        <button class="btn-action success" id="btnTestInference">
                            <span>🔍</span> Test Inference
                        </button>
                        <button class="btn-action warning" id="btnUploadImage">
                            <span>📤</span> Upload Image
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- System Tab -->
            <div class="tab-content" id="system-tab">
                <div class="settings-section">
                    <h4>System Information</h4>
                    <div class="info-group">
                        <div class="info-item">
                            <span class="info-label">Application Version:</span>
                            <span class="info-value">1.0.0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Framework:</span>
                            <span class="info-value">.NET 9.0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Environment:</span>
                            <span class="info-value">Development</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize MapLibre map (free, no token required)
        const phBounds = [
            [116.0, 4.2],   // Southwest [lng, lat]
            [127.5, 21.5]   // Northeast [lng, lat]
        ];
        
        var map = new maplibregl.Map({
            container: 'map',
            style: {
                'version': 8,
                'sources': {
                    'osm': {
                        'type': 'raster',
                        'tiles': [
                            'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
                            'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                            'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
                        ],
                        'tileSize': 256,
                        'attribution': '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    },
                    'satellite': {
                        'type': 'raster',
                        'tiles': [
                            'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
                        ],
                        'tileSize': 256,
                        'attribution': 'Tiles © Esri — Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
                    }
                },
                'layers': [
                    {
                        'id': 'osm',
                        'type': 'raster',
                        'source': 'osm',
                        'minzoom': 0,
                        'maxzoom': 19
                    }
                ]
            },
            bounds: phBounds,
            fitBoundsOptions: {
                padding: 20
            },
            minZoom: 5,
            maxZoom: 19
        });
        
        // Restrict map to Philippines bounds
        map.setMaxBounds(phBounds);
        
        // 3D and style control variables
        let is3DMode = false;
        let currentStyle = 'streets';
        
        // Add map controls
        map.addControl(new maplibregl.NavigationControl(), 'top-right');
        map.addControl(new maplibregl.FullscreenControl(), 'top-right');
        
        // Create custom style switcher control
        class StyleSwitcherControl {
            onAdd(map) {
                this._map = map;
                this._container = document.createElement('div');
                this._container.className = 'maplibregl-ctrl maplibregl-ctrl-group';
                this._container.innerHTML = `
                    <button id="styleBtn" type="button" title="Switch Map Style" style="background: white; border: none; width: 30px; height: 30px; cursor: pointer;">
                        <i class="fas fa-layer-group" style="color: #666;"></i>
                    </button>
                `;
                this._container.addEventListener('click', this._toggleStyle.bind(this));
                return this._container;
            }
            
            onRemove() {
                this._container.parentNode.removeChild(this._container);
                this._map = undefined;
            }
            
            _toggleStyle() {
                const btn = document.getElementById('styleBtn');
                if (currentStyle === 'streets') {
                    // Switch to satellite
                    map.removeLayer('osm');
                    map.addLayer({
                        'id': 'satellite',
                        'type': 'raster',
                        'source': 'satellite',
                        'minzoom': 0,
                        'maxzoom': 19
                    });
                    currentStyle = 'satellite';
                    btn.innerHTML = '<i class="fas fa-map" style="color: #666;"></i>';
                    document.getElementById('threeDBtn').style.display = 'block';
                } else {
                    // Switch to streets
                    map.removeLayer('satellite');
                    map.addLayer({
                        'id': 'osm',
                        'type': 'raster',
                        'source': 'osm',
                        'minzoom': 0,
                        'maxzoom': 19
                    });
                    currentStyle = 'streets';
                    btn.innerHTML = '<i class="fas fa-layer-group" style="color: #666;"></i>';
                    document.getElementById('threeDBtn').style.display = 'none';
                    if (is3DMode) {
                        toggle3DMode();
                    }
                }
            }
        }
        
        // Create custom 3D control
        class ThreeDControl {
            onAdd(map) {
                this._map = map;
                this._container = document.createElement('div');
                this._container.className = 'maplibregl-ctrl maplibregl-ctrl-group';
                this._container.innerHTML = `
                    <button id="threeDBtn" type="button" title="Toggle 3D View" style="background: white; border: none; width: 30px; height: 30px; cursor: pointer; display: none;">
                        <i class="fas fa-cube" style="color: #666;"></i>
                    </button>
                `;
                this._container.addEventListener('click', toggle3DMode);
                return this._container;
            }
            
            onRemove() {
                this._container.parentNode.removeChild(this._container);
                this._map = undefined;
            }
        }
        
        // Add custom controls
        map.addControl(new StyleSwitcherControl(), 'top-right');
        map.addControl(new ThreeDControl(), 'top-right');
        
        // 3D mode toggle function
        function toggle3DMode() {
            is3DMode = !is3DMode;
            const btn = document.getElementById('threeDBtn');
            
            if (is3DMode) {
                btn.style.background = '#007cff';
                btn.innerHTML = '<i class="fas fa-cube" style="color: white;"></i>';
                
                // Set 3D view angle
                map.easeTo({
                    pitch: 60,
                    bearing: 20,
                    duration: 1000
                });
                
                showInstructions();
                
            } else {
                btn.style.background = 'white';
                btn.innerHTML = '<i class="fas fa-cube" style="color: #666;"></i>';
                
                // Reset to 2D view
                map.easeTo({
                    pitch: 0,
                    bearing: 0,
                    duration: 1000
                });
                
                hideInstructions();
            }
        }
        
        function showInstructions() {
            let instructionsDiv = document.getElementById('map-instructions');
            if (!instructionsDiv) {
                instructionsDiv = document.createElement('div');
                instructionsDiv.id = 'map-instructions';
                instructionsDiv.className = 'threeDMode-instructions';
                instructionsDiv.innerHTML = '<strong>3D Mode Active</strong><br>Right-click + drag to rotate<br>Ctrl + drag to tilt<br>Scroll to zoom';
                document.getElementById('map').appendChild(instructionsDiv);
            }
            instructionsDiv.style.display = 'block';
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                instructionsDiv.style.display = 'none';
            }, 5000);
        }
        
        function hideInstructions() {
            const instructionsDiv = document.getElementById('map-instructions');
            if (instructionsDiv) {
                instructionsDiv.style.display = 'none';
            }
        }
        
        // Camera markers and geofences (using MapLibre markers)
        const cameraMarkers = [];
        const geofenceMarkers = [];

        // Hide all sections initially (no cameras yet) and show placeholder
        ['section-1', 'section-2', 'section-3'].forEach(id => document.getElementById(id).classList.add('hidden'));
        document.getElementById('no-cameras').classList.remove('hidden');

        // Remove demo auto-loading for camera 2

        // Removed an unused single analytics chart setup to avoid errors

        // Initialize analytics charts
        function createAnalyticsChart(canvasId) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['12:00', '12:05', '12:10', '12:15', '12:20', '12:25'],
                    datasets: [{
                        label: 'Water Level',
                        data: [0, 0.5, 1.2, 0.8, 0.3, 0],
                        fill: true,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                display: false
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // Create charts for each camera
        const charts = [
            createAnalyticsChart('analytics1'),
            createAnalyticsChart('analytics2'),
            createAnalyticsChart('analytics3')
        ];

        // Simulate camera feeds
        function simulateCameraFeed(cameraId) {
            const timestamp = new Date().getTime();
            document.getElementById(`${cameraId}-original`).src = `https://picsum.photos/640/360?t=${timestamp}`;
            document.getElementById(`${cameraId}-ai`).src = `https://picsum.photos/640/360?t=${timestamp + 1}`;
        }

        // Registry for camera slots and helpers
        const cameraSlots = {
            1: {row: 'row-1', orig: 'camera1-original', ai: 'camera1-ai', lu: 'lu-1'},
            2: {row: 'row-2', orig: 'camera2-original', ai: 'camera2-ai', lu: 'lu-2'},
            3: {row: 'row-3', orig: 'camera3-original', ai: 'camera3-ai', lu: 'lu-3'}
        };

        // Update charts with random data periodically
        setInterval(() => {
            charts.forEach(chart => {
                const newData = chart.data.datasets[0].data.slice(1);
                newData.push(Math.random() * 2);
                chart.data.datasets[0].data = newData;
                chart.update('none');
            });
        }, 5000);

        // Header clock and last update stamps
        function updateClock() {
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const clockStr = now.toLocaleString(undefined, {
                weekday: 'short', year: 'numeric', month: 'short', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit'
            });
            document.getElementById('headerClock').textContent = clockStr;
        }
        setInterval(updateClock, 1000);
        updateClock();

        function setLastUpdate(id) {
            const el = document.getElementById(id);
            if (el) {
                el.textContent = new Date().toLocaleString();
            }
        }
        ['lu-1','lu-2','lu-3'].forEach(setLastUpdate);

        // Actions dropdown behavior
        document.querySelectorAll('.btn-actions').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const idx = btn.getAttribute('data-actions');
                const menu = document.getElementById(`menu-${idx}`);
                // close others
                document.querySelectorAll('.dropdown-menu').forEach(m => m.style.display = 'none');
                menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
                e.stopPropagation();
            });
        });
        document.addEventListener('click', () => {
            document.querySelectorAll('.dropdown-menu').forEach(m => m.style.display = 'none');
        });

        // Demo file picker: load image/video into both original and AI of the selected section
        function bindDemoHandlers() {
            document.querySelectorAll('.dropdown-item[data-action="demo"]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const sectionIdx = btn.getAttribute('data-section');
                    // build a hidden file input on the fly
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = 'image/*,video/*';
                    fileInput.onchange = (e) => {
                        const file = e.target.files?.[0];
                        if (!file) return;
                        const url = URL.createObjectURL(file);
                        // target ids
                        const origId = `camera${sectionIdx}-original`;
                        const aiId = `camera${sectionIdx}-ai`;
                        // swap img elements for video if needed
                        const isVideo = file.type.startsWith('video/');
                        [origId, aiId].forEach((id) => {
                            const container = document.getElementById(id).parentElement;
                            // remove existing img/video
                            container.querySelectorAll('img,video').forEach(el => el.remove());
                            let mediaEl;
                            if (isVideo) {
                                mediaEl = document.createElement('video');
                                mediaEl.autoplay = true; mediaEl.loop = true; mediaEl.muted = true; mediaEl.controls = true;
                            } else {
                                mediaEl = document.createElement('img');
                            }
                            mediaEl.id = id;
                            mediaEl.className = 'camera-img camera-media-contain';
                            mediaEl.src = url;
                            container.appendChild(mediaEl);
                            // hide no-signal overlays
                            const ns = container.querySelector('.no-signal');
                            if (ns) ns.style.display = 'none';
                        });

                        // Auto-trigger AI detection for any camera
                        setTimeout(async () => {
                            try {
                                const aiEl = document.getElementById(`camera${sectionIdx}-ai`);
                                if (aiEl && (aiEl.tagName === 'IMG' || aiEl.tagName === 'VIDEO')) {
                                    const canvas = document.createElement('canvas');
                                    const w = aiEl.clientWidth || aiEl.naturalWidth || 640;
                                    const h = aiEl.clientHeight || aiEl.naturalHeight || 360;
                                    canvas.width = w; canvas.height = h;
                                    const ctx = canvas.getContext('2d');

                                    if (aiEl.tagName === 'IMG' && aiEl.complete) {
                                        ctx.drawImage(aiEl, 0, 0, w, h);
                                    } else if (aiEl.tagName === 'VIDEO' && aiEl.readyState >= 2) {
                                        ctx.drawImage(aiEl, 0, 0, w, h);
                                    }

                                    const imageData = canvas.toDataURL('image/jpeg');
                                    console.log(`Sending detection request for camera ${sectionIdx}...`);
                                    const resp = await fetch('http://127.0.0.1:5001/detect', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ imageData })
                                    });

                                    console.log('Detection response status:', resp.status);
                                    if (resp.ok) {
                                        const result = await resp.json();
                                        console.log(`Detection result for camera ${sectionIdx}:`, result);
                                        if (Array.isArray(result.detections)) {
                                            console.log('Rendering detections:', result.detections.length);
                                            renderDetections(parseInt(sectionIdx), result.detections, result.frameW, result.frameH);
                                            if (typeof result.gaugePct === 'number') {
                                                console.log('Setting gauge to:', result.gaugePct);
                                                setGauge(parseInt(sectionIdx), result.gaugePct);
                                            }
                                        }
                                    } else {
                                        console.error('Detection request failed:', resp.status, resp.statusText);
                                    }
                                }
                            } catch (error) {
                                console.log(`Detection error for camera ${sectionIdx}:`, error);
                            }
                        }, 1000); // Wait 1 second for media to load
                    };
                    fileInput.click();
                });
            });
        }
        bindDemoHandlers();

        // Configure camera handlers
        function bindConfigureHandlers() {
            document.querySelectorAll('.dropdown-item[data-action="configure"]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const sectionIdx = btn.getAttribute('data-section');
                    openConfigureModal(sectionIdx);
                });
            });
        }
        bindConfigureHandlers();

        // Delete camera handlers
        function bindDeleteHandlers() {
            document.querySelectorAll('.dropdown-item[data-action="delete"]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const sectionIdx = btn.getAttribute('data-section');
                    deleteCamera(sectionIdx);
                });
            });
        }
        bindDeleteHandlers();

        // Example: function to programmatically set gauge value (0-100) for any camera
        function setGauge(cameraSlot, percent) {
            console.log(`setGauge called for camera ${cameraSlot} with:`, percent);
            const clamped = Math.max(0, Math.min(100, percent));
            const fill = document.getElementById(`gauge${cameraSlot}-fill`);
            console.log('Gauge fill element:', fill);
            if (fill) {
                fill.style.height = clamped + '%';
                console.log('Set gauge height to:', clamped + '%');
            } else {
                console.error(`Gauge fill element for camera ${cameraSlot} not found!`);
            }
        }

        // Legacy function for backward compatibility
        function setGauge2(percent) {
            setGauge(2, percent);
        }

        // Draw detections (boxes/labels) on overlay canvas for any camera
        function renderDetections(cameraSlot, dets, srcW, srcH) {
            console.log(`renderDetections called for camera ${cameraSlot} with:`, dets.length, 'detections');
            const canvas = document.getElementById(`det${cameraSlot}`);
            const img = document.getElementById(`camera${cameraSlot}-ai`);
            console.log('Canvas:', canvas, 'Image:', img);
            if (!canvas || !img) {
                console.error(`Missing canvas or image element for camera ${cameraSlot}`);
                return;
            }
            // Match overlay to on-screen size
            const cw = img.clientWidth || img.videoWidth || img.naturalWidth || 640;
            const ch = img.clientHeight || img.videoHeight || img.naturalHeight || 360;
            canvas.width = cw;
            canvas.height = ch;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const scaleX = srcW ? cw / srcW : 1;
            const scaleY = srcH ? ch / srcH : 1;
            dets.forEach(d => {
                const {x, y, w, h, label, score, color = 'rgba(66,133,244,0.9)'} = d;
                const sx = x * scaleX, sy = y * scaleY, sw = w * scaleX, sh = h * scaleY;
                ctx.strokeStyle = color; ctx.lineWidth = 2;
                ctx.strokeRect(sx, sy, sw, sh);
                ctx.fillStyle = color;
                const text = `${label}${typeof score === 'number' ? ' ' + score.toFixed(2) : ''}`;
                const pad = 2; const th = 14; const tw = ctx.measureText(text).width + 8;
                ctx.fillRect(sx, Math.max(0, sy - th), tw, th);
                ctx.fillStyle = '#fff'; ctx.font = '12px Segoe UI, Arial'; ctx.fillText(text, sx + pad, sy - 3);
            });
        }

        // Legacy function for backward compatibility
        function renderDetections2(dets, srcW, srcH) {
            renderDetections(2, dets, srcW, srcH);
        }

        // RTSP streaming function - gets frames from detection service
        let streamingIntervals = {};
        
        async function startRtspStreaming(cameraSlot, rtspUrl) {
            // Clear any existing interval for this slot
            if (streamingIntervals[cameraSlot]) {
                clearInterval(streamingIntervals[cameraSlot]);
            }
            
            const origImg = document.getElementById(`camera${cameraSlot}-original`);
            const aiImg = document.getElementById(`camera${cameraSlot}-ai`);
            
            if (!origImg || !aiImg) return;
            
            // Function to get and display a frame
            const getFrame = async () => {
                try {
                    const response = await fetch('http://127.0.0.1:5001/detect', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ source: rtspUrl })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        
                        if (result.error) {
                            console.error('RTSP Stream Error:', result.error);
                            // Show error in original frame
                            origImg.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQwIiBoZWlnaHQ9IjM2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGMzNTQ1Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkNhbWVyYSBFcnJvcjwvdGV4dD48L3N2Zz4=';
                            return;
                        }
                        
                        // If we have actual frame data, use it
                        if (result.frameData) {
                            const frameDataUrl = `data:image/jpeg;base64,${result.frameData}`;
                            origImg.src = frameDataUrl;
                            
                            // Create AI canvas with detections overlaid
                            if (result.frameW && result.frameH) {
                                const canvas = document.createElement('canvas');
                                canvas.width = result.frameW;
                                canvas.height = result.frameH;
                                const ctx = canvas.getContext('2d');
                                
                                // Draw the original frame
                                const tempImg = new Image();
                                tempImg.onload = () => {
                                    ctx.drawImage(tempImg, 0, 0);
                                    
                                    // Draw detections on top
                                    if (Array.isArray(result.detections)) {
                                        result.detections.forEach(det => {
                                            if (det.color) ctx.strokeStyle = det.color;
                                            else ctx.strokeStyle = 'rgba(255,0,0,0.8)';
                                            ctx.lineWidth = 2;
                                            ctx.strokeRect(det.x, det.y, det.w, det.h);
                                            
                                            // Label background
                                            ctx.fillStyle = ctx.strokeStyle;
                                            const text = `${det.label} ${(det.score * 100).toFixed(0)}%`;
                                            ctx.font = '12px Arial';
                                            const textWidth = ctx.measureText(text).width;
                                            ctx.fillRect(det.x, det.y - 20, textWidth + 8, 20);
                                            
                                            // Label text
                                            ctx.fillStyle = '#fff';
                                            ctx.fillText(text, det.x + 4, det.y - 6);
                                        });
                                    }
                                    
                                    // Set AI image source
                                    aiImg.src = canvas.toDataURL('image/jpeg', 0.9);
                                };
                                tempImg.src = frameDataUrl;
                            }
                            
                            if (typeof result.gaugePct === 'number') {
                                setGauge(cameraSlot, result.gaugePct);
                            }
                            
                            // Update last update time
                            const slot = cameraSlots[cameraSlot];
                            if (slot) setLastUpdate(slot.lu);
                        }
                    }
                } catch (error) {
                    console.error('RTSP streaming error:', error);
                    origImg.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQwIiBoZWlnaHQ9IjM2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGMzNTQ1Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iI2ZmZiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkNvbm5lY3Rpb24gRXJyb3I8L3RleHQ+PC9zdmc+';
                }
            };
            
            // Get initial frame
            await getFrame();
            
            // Set up interval to get frames every 2 seconds (adjust as needed)
            streamingIntervals[cameraSlot] = setInterval(getFrame, 2000);
        }

        async function runDetectionFromCurrentMedia(cameraSlot = null) {
            // If no specific slot provided, run detection on all active cameras
            if (cameraSlot === null) {
                for (let slot = 1; slot <= 3; slot++) {
                    const section = document.getElementById(`section-${slot}`);
                    if (section && !section.classList.contains('hidden')) {
                        await runDetectionFromCurrentMedia(slot);
                    }
                }
                return;
            }

            // Check if this is an RTSP camera - if so, streaming handles detection
            const section = document.getElementById(`section-${cameraSlot}`);
            if (section && section.getAttribute('data-camera-type') === 'rtsp') {
                return; // RTSP streaming handles detection automatically
            }

            const aiEl = document.getElementById(`camera${cameraSlot}-ai`);
            if (!aiEl) return;
            const canvas = document.createElement('canvas');
            const w = aiEl.clientWidth || aiEl.videoWidth || aiEl.naturalWidth || 640;
            const h = aiEl.clientHeight || aiEl.videoHeight || aiEl.naturalHeight || 360;
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            try {
                ctx.drawImage(aiEl, 0, 0, w, h);
            } catch { return; }
            const imageData = canvas.toDataURL('image/jpeg');
            try {
                const resp = await fetch('http://127.0.0.1:5001/detect', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ imageData })});
                if (resp.ok) {
                    const result = await resp.json();
                    if (Array.isArray(result.detections)) renderDetections(cameraSlot, result.detections, result.frameW, result.frameH);
                    if (typeof result.gaugePct === 'number') setGauge(cameraSlot, result.gaugePct);
                }
            } catch {}
        }

        // Connections modal logic
        const connectionModal = document.getElementById('connectionModal');
        function openConnections() { connectionModal.classList.remove('hidden'); }
        function closeConnections() { connectionModal.classList.add('hidden'); }
        document.getElementById('menuConnection').addEventListener('click', openConnections);
        document.getElementById('connClose').addEventListener('click', closeConnections);
        connectionModal.querySelector('.modal-backdrop').addEventListener('click', closeConnections);

        // Configure modal functionality
        const configureModal = document.getElementById('configureModal');
        let currentConfigureSection = null;

        function openConfigureModal(sectionIdx) {
            currentConfigureSection = sectionIdx;
            configureModal.classList.remove('hidden');
            
            // Load current camera data if it exists
            loadCameraData(sectionIdx);
        }

        function closeConfigureModal() {
            configureModal.classList.add('hidden');
            currentConfigureSection = null;
        }

        function loadCameraData(sectionIdx) {
            // Load existing camera configuration data
            // For now, just clear the form - in a real app, you'd load from storage/server
            document.getElementById('configIpAddress').value = '';
            document.getElementById('configPort').value = '';
            document.getElementById('configChannel').value = 'Streaming/Channels/101';
            document.getElementById('configUsername').value = '';
            document.getElementById('configPassword').value = '';
            document.getElementById('configLocName').value = '';
            document.getElementById('configLatitude').value = '';
            document.getElementById('configLongitude').value = '';
        }

        function saveConfiguration() {
            if (!currentConfigureSection) return;
            
            const config = {
                ipAddress: document.getElementById('configIpAddress').value,
                port: document.getElementById('configPort').value,
                channel: document.getElementById('configChannel').value,
                username: document.getElementById('configUsername').value,
                password: document.getElementById('configPassword').value,
                locationName: document.getElementById('configLocName').value,
                latitude: document.getElementById('configLatitude').value,
                longitude: document.getElementById('configLongitude').value
            };

            // Validate required fields
            if (!config.ipAddress || !config.locationName || !config.latitude || !config.longitude) {
                alert('Please fill in all required fields (IP Address, Location Name, Latitude, Longitude)');
                return;
            }

            // Update the camera section title
            const section = document.getElementById(`section-${currentConfigureSection}`);
            if (section) {
                const titleElement = section.querySelector('.panel-title');
                if (titleElement) {
                    titleElement.textContent = config.locationName;
                }
            }

            // In a real app, you would save this to localStorage or send to server
            console.log('Saving camera configuration for section', currentConfigureSection, config);
            
            // Show success message
            alert('Camera configuration saved successfully!');
            
            closeConfigureModal();
        }

        function deleteCamera(sectionIdx) {
            if (confirm('Are you sure you want to delete this camera? This action cannot be undone.')) {
                const section = document.getElementById(`section-${sectionIdx}`);
                if (section) {
                    section.classList.add('hidden');
                    
                    // Reset camera content
                    const originalImg = document.getElementById(`camera${sectionIdx}-original`);
                    const aiImg = document.getElementById(`camera${sectionIdx}-ai`);
                    const nosignalOriginal = document.getElementById(`camera${sectionIdx}-nosignal`);
                    const nosignalAi = document.getElementById(`camera${sectionIdx}-ai-nosignal`);
                    
                    if (originalImg) originalImg.src = '';
                    if (aiImg) aiImg.src = '';
                    if (nosignalOriginal) nosignalOriginal.style.display = 'block';
                    if (nosignalAi) nosignalAi.style.display = 'block';
                    
                    // Clear gauge
                    setGauge(sectionIdx, 0);
                    
                    // Check if no cameras are visible
                    const visibleSections = document.querySelectorAll('.location-section:not(.hidden)');
                    if (visibleSections.length === 0) {
                        document.getElementById('no-cameras').classList.remove('hidden');
                    }
                    
                    // In a real app, you would also remove from localStorage or send delete request to server
                    console.log('Deleted camera from section', sectionIdx);
                }
            }
        }

        // Configure modal event listeners
        document.getElementById('configureClose').addEventListener('click', closeConfigureModal);
        document.getElementById('configCancel').addEventListener('click', closeConfigureModal);
        document.getElementById('configSave').addEventListener('click', saveConfiguration);
        configureModal.querySelector('.modal-backdrop').addEventListener('click', closeConfigureModal);

        // Configure map button functionality
        document.getElementById('configBtnMap').addEventListener('click', () => {
            // Open map picker for configure modal
            openPicker();
        });

        // Map Picker logic - Using Leaflet for reliability
        let pickerMap, polygonPoints = [], drawnShape, isPolygonMode = false, polygonPointMarkers = [];
        let pickerCurrentStyle = 'streets';
        
        function openPicker() {
            document.getElementById('mapPicker').classList.remove('hidden');
            setTimeout(() => {
                if (!pickerMap) {
                    try {
                        // Use Leaflet for the picker map - it's more reliable
                        const phBounds = L.latLngBounds(
                            L.latLng(4.2, 116.0),   // Southwest
                            L.latLng(21.5, 127.5)   // Northeast
                        );
                        
                        pickerMap = L.map('pickerMap', {
                            maxBounds: phBounds,
                            maxBoundsViscosity: 1.0,
                            minZoom: 5,
                            maxZoom: 19,
                            worldCopyJump: false
                        }).fitBounds(phBounds);
                        
                        // Add OpenStreetMap tiles
                        const osmLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            maxZoom: 19,
                            attribution: '© OpenStreetMap contributors'
                        }).addTo(pickerMap);
                        
                        // Add satellite layer
                        const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                            maxZoom: 19,
                            attribution: 'Tiles © Esri'
                        });
                        
                        // Create layer control
                        const baseMaps = {
                            "Street Map": osmLayer,
                            "Satellite": satelliteLayer
                        };
                        
                        L.control.layers(baseMaps).addTo(pickerMap);
                        
                        // Update coordinates on map move
                        pickerMap.on('move', () => {
                            const center = pickerMap.getCenter();
                            document.getElementById('pickerLat').value = center.lat.toFixed(6);
                            document.getElementById('pickerLng').value = center.lng.toFixed(6);
                        });
                        
                        // Handle clicks for polygon mode
                        pickerMap.on('click', (e) => {
                            if (isPolygonMode) {
                                polygonPoints.push([e.latlng.lat, e.latlng.lng]);
                                
                                // Add visual point marker
                                const pointMarker = L.circleMarker(e.latlng, {
                                    radius: 5,
                                    color: '#2a8',
                                    fillColor: '#2a8',
                                    fillOpacity: 0.8
                                }).addTo(pickerMap);
                                
                                polygonPointMarkers.push(pointMarker);
                                
                                if (polygonPoints.length > 2) {
                                    drawPolygon();
                                }
                            }
                        });
                        
                        // Set initial center
                        pickerMap.setView([14.5995, 120.9842], 8);
                        
                    } catch (error) {
                        console.error('Failed to initialize picker map:', error);
                        // Fallback: just show coordinates input
                        document.getElementById('pickerLat').value = '14.5995';
                        document.getElementById('pickerLng').value = '120.9842';
                    }
                } else {
                    // Map already exists, just sync with main map if possible
                    try {
                        if (map && map.getCenter) {
                            const mainCenter = map.getCenter();
                            const mainZoom = map.getZoom();
                            pickerMap.setView([mainCenter.lat, mainCenter.lng], mainZoom);
                        }
                        pickerMap.invalidateSize(); // Force redraw
                    } catch (error) {
                        console.error('Failed to sync picker map:', error);
                        pickerMap.invalidateSize();
                    }
                }
            }, 100);
        }
        
        function togglePickerStyle() {
            if (!pickerMap) return;
            
            const btn = document.getElementById('pickerToggleBtn');
            try {
                if (pickerCurrentStyle === 'streets') {
                    // Switch to satellite
                    if (pickerMap.getLayer('osm-layer')) {
                        pickerMap.removeLayer('osm-layer');
                    }
                    pickerMap.addLayer({
                        'id': 'satellite-layer',
                        'type': 'raster',
                        'source': 'satellite-raster'
                    });
                    pickerCurrentStyle = 'satellite';
                    btn.innerHTML = '<i class="fas fa-map" style="color: #666; font-size: 12px;"></i>';
                } else {
                    // Switch to streets
                    if (pickerMap.getLayer('satellite-layer')) {
                        pickerMap.removeLayer('satellite-layer');
                    }
                    pickerMap.addLayer({
                        'id': 'osm-layer',
                        'type': 'raster',
                        'source': 'osm-raster'
                    });
                    pickerCurrentStyle = 'streets';
                    btn.innerHTML = '<i class="fas fa-satellite" style="color: #666; font-size: 12px;"></i>';
                }
            } catch (error) {
                console.error('Failed to toggle picker style:', error);
            }
        }
        function closePicker(){ 
            document.getElementById('mapPicker').classList.add('hidden'); 
        }
        document.getElementById('btnMap').addEventListener('click', openPicker);
        document.getElementById('pickerClose').addEventListener('click', closePicker);
        document.querySelector('.map-picker-backdrop').addEventListener('click', closePicker);

        function drawCircle(){
            if (!pickerMap) return;
            
            isPolygonMode = false; 
            polygonPoints = [];
            
            // Clear polygon point markers
            polygonPointMarkers.forEach(marker => {
                try {
                    if (pickerMap) pickerMap.removeLayer(marker);
                } catch (error) {
                    console.error('Failed to clear marker:', error);
                }
            });
            polygonPointMarkers = [];
            
            try {
                // Remove existing shape
                if (drawnShape) {
                    pickerMap.removeLayer(drawnShape);
                    drawnShape = null;
                }
                
                const center = pickerMap.getCenter();
                const radius = Number(document.getElementById('pickerRadius').value || 200);
                
                drawnShape = L.circle(center, {
                    radius: radius,
                    color: '#2a8',
                    weight: 3,
                    fillOpacity: 0.1
                }).addTo(pickerMap);
                
            } catch (error) {
                console.error('Failed to draw circle:', error);
            }
        }
        
        function drawPolygon(){
            if (!pickerMap) return;
            
            try {
                // Remove existing shape
                if (drawnShape) {
                    pickerMap.removeLayer(drawnShape);
                    drawnShape = null;
                }
                
                if (polygonPoints.length > 2) {
                    drawnShape = L.polygon(polygonPoints, {
                        color: '#2a8',
                        weight: 3,
                        fillOpacity: 0.1
                    }).addTo(pickerMap);
                }
            } catch (error) {
                console.error('Failed to draw polygon:', error);
            }
        }
        
        // Auto polygon cover (approximate) around currently visible bounds
        function autoCoverBounds() {
            if (!pickerMap) return;
            
            try {
                const bounds = pickerMap.getBounds();
                const sw = bounds.getSouthWest();
                const ne = bounds.getNorthEast();
                const nw = L.latLng(ne.lat, sw.lng);
                const se = L.latLng(sw.lat, ne.lng);
                
                polygonPoints = [[sw.lat, sw.lng], [nw.lat, nw.lng], [ne.lat, ne.lng], [se.lat, se.lng]];
                drawPolygon();
            } catch (error) {
                console.error('Failed to auto cover bounds:', error);
            }
        }
        
        document.getElementById('pickerCircle').addEventListener('click', () => { drawCircle(); });
        document.getElementById('pickerPolygon').addEventListener('click', () => { 
            clearDrawnShape(); // Clear any existing shapes and markers
            isPolygonMode = true; 
            polygonPoints = []; 
            polygonPointMarkers = [];
        });
        
        document.getElementById('pickerAutoCover').addEventListener('click', () => { autoCoverBounds(); });
        document.getElementById('pickerClear').addEventListener('click', () => { clearDrawnShape(); });
        
        function clearDrawnShape() {
            if (drawnShape && pickerMap) { 
                try {
                    pickerMap.removeLayer(drawnShape); 
                    drawnShape = null; 
                } catch (error) {
                    console.error('Failed to clear shape:', error);
                }
            }
            
            // Clear polygon point markers
            polygonPointMarkers.forEach(marker => {
                try {
                    if (pickerMap) pickerMap.removeLayer(marker);
                } catch (error) {
                    console.error('Failed to clear marker:', error);
                }
            });
            polygonPointMarkers = [];
            polygonPoints = [];
            isPolygonMode = false;
            
            // Clear polygon point markers
            if (polygonPointMarkers && polygonPointMarkers.length > 0) {
                polygonPointMarkers.forEach(marker => {
                    try {
                        pickerMap.removeLayer(marker);
                    } catch (error) {
                        console.error('Failed to remove marker:', error);
                    }
                });
                polygonPointMarkers = [];
            }
            
            // Reset polygon mode and points
            isPolygonMode = false;
            polygonPoints = [];
        }
        // Create a quick actions bar for automatic cover
        const footer = document.querySelector('.map-picker-footer .picker-controls');
        if (footer) {
            const btnAuto = document.createElement('button');
            btnAuto.className = 'btn'; btnAuto.textContent = 'Auto Cover';
            btnAuto.addEventListener('click', autoCoverBounds);
            footer.appendChild(btnAuto);
        }
        document.getElementById('pickerClear').addEventListener('click', () => { if (drawnShape) { pickerMap.removeLayer(drawnShape); } polygonPoints = []; });
        document.getElementById('pickerUse').addEventListener('click', () => {
            const c = pickerMap.getCenter();
            document.getElementById('latitude').value = c.lat.toFixed(6);
            document.getElementById('longitude').value = c.lng.toFixed(6);
            closePicker();
        });

        // Build stream URL (supports RTSP with optional user/pass/port/channel)
        function buildStreamUrl() {
            const ip = (document.getElementById('ipAddress').value || '').trim();
            const port = (document.getElementById('port').value || '').trim();
            const channel = (document.getElementById('channel').value || '').trim();
            const user = (document.getElementById('username').value || '').trim();
            const pass = (document.getElementById('password').value || '').trim();
            if (!ip) return '';

            // If user provided full URL, respect it and just inject credentials if missing
            let url = ip.match(/^https?:\/\//i) || ip.match(/^rtsp:\/\//i) ? ip : `rtsp://${ip}`;

            // Insert credentials - fix the at symbol issue
            if (user) {
                const [scheme, rest] = url.split('://');
                const atSymbol = String.fromCharCode(64); // at character
                if (rest && rest.indexOf(atSymbol) === -1) {
                    url = `${scheme}://${user}${pass ? ':' + pass : ''}${atSymbol}${rest}`;
                }
            }

            // Insert port if provided and none present
            if (port && !/:[0-9]+/.test((url.split('://')[1] || ''))) {
                const [scheme, rest] = url.split('://');
                const host = (rest || '').split('/')[0];
                const path = (rest || '').split('/').slice(1).join('/');
                url = `${scheme}://${host}:${port}/${path}`.replace(/:\/:/,'://');
            }

            // Append channel if provided
            if (channel && url.indexOf(channel) === -1) {
                if (!url.endsWith('/')) url += '/';
                url += channel;
            }
            return url;
        }

        // Preview handling (browser supports HTTP(S) video/image; RTSP requires external player)
        function showPreview(url) {
            const preview = document.getElementById('connPreview');
            preview.innerHTML = '';
            if (!url) return;
            
            const isRtsp = /^rtsp:\/\//i.test(url);
            const videoLike = /\.(mp4|webm|ogg|m3u8)(\?|$)/i.test(url);
            const imageLike = /\.(png|jpe?g|gif)(\?|$)/i.test(url) || /snapshot|picture/i.test(url);
            
            if (imageLike) {
                const img = document.createElement('img');
                img.src = url; 
                img.style.maxWidth = '100%'; 
                img.style.maxHeight = '100%';
                img.style.objectFit = 'contain';
                img.onerror = () => {
                    preview.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545;">Failed to load image from: ' + url + '</div>';
                };
                preview.appendChild(img);
            } else if (!isRtsp && videoLike) {
                const vid = document.createElement('video');
                vid.src = url; 
                vid.autoplay = true; 
                vid.muted = true; 
                vid.loop = true; 
                vid.controls = true;
                vid.style.maxWidth = '100%'; 
                vid.style.maxHeight = '100%';
                vid.style.objectFit = 'contain';
                vid.onerror = () => {
                    preview.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc3545;">Failed to load video from: ' + url + '</div>';
                };
                preview.appendChild(vid);
            } else if (isRtsp) {
                const container = document.createElement('div');
                container.style.padding = '20px';
                container.style.textAlign = 'center';
                container.style.background = '#f8f9fa';
                container.style.border = '2px dashed #dee2e6';
                container.style.borderRadius = '8px';
                container.innerHTML = `
                    <div style="margin-bottom: 15px;">
                        <svg width="48" height="48" fill="#6c757d" viewBox="0 0 16 16">
                            <path d="M6.5 1A1.5 1.5 0 0 0 5 2.5v3A1.5 1.5 0 0 0 6.5 7h3A1.5 1.5 0 0 0 11 5.5v-3A1.5 1.5 0 0 0 9.5 1h-3zM11 5.5a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3z"/>
                            <path d="M2 9a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V9zm10.5 1a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0zm1.5 0a.5.5 0 1 0-1 0 .5.5 0 0 0 1 0z"/>
                        </svg>
                    </div>
                    <h5 style="color: #495057; margin-bottom: 10px;">RTSP Stream Configured</h5>
                    <p style="color: #6c757d; margin-bottom: 15px; font-size: 14px;">
                        RTSP streams cannot be previewed directly in web browsers.<br>
                        Testing connection to detection service...
                    </p>
                    <div id="rtsp-status" style="margin-bottom: 15px;">
                        <div class="spinner-border spinner-border-sm text-primary" role="status">
                            <span class="sr-only">Testing...</span>
                        </div>
                        <span style="margin-left: 10px; color: #6c757d;">Connecting...</span>
                    </div>
                    <div style="font-size: 12px; color: #868e96; background: white; padding: 8px; border-radius: 4px; border: 1px solid #e9ecef;">
                        <strong>Stream URL:</strong> ${url}
                    </div>
                `;
                preview.appendChild(container);
                
                // Test RTSP connection via detection service
                testRtspConnection(url);
            } else {
                const container = document.createElement('div');
                container.style.padding = '20px';
                container.style.textAlign = 'center';
                container.style.color = '#dc3545';
                container.innerHTML = `
                    <h5>Unsupported Format</h5>
                    <p>The URL format is not supported for preview.</p>
                    <small>Supported: HTTP/HTTPS images, videos, and RTSP streams</small>
                `;
                preview.appendChild(container);
            }
        }

        async function testRtspConnection(url) {
            const statusEl = document.getElementById('rtsp-status');
            if (!statusEl) return;
            
            try {
                const response = await fetch('http://127.0.0.1:5001/test_rtsp', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ source: url })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusEl.innerHTML = `
                        <div style="color: #28a745;">
                            <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.061L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"/>
                            </svg>
                            Connection Successful
                        </div>
                        <div style="font-size: 12px; color: #6c757d; margin-top: 5px;">
                            Resolution: ${result.width}x${result.height}, FPS: ${result.fps || 'Unknown'}
                        </div>
                    `;
                    
                    // Update main status
                    const connStatus = document.getElementById('connStatus');
                    if (connStatus) {
                        connStatus.textContent = 'RTSP Camera Connected ✓';
                        connStatus.style.color = '#28a745';
                    }
                } else {
                    statusEl.innerHTML = `
                        <div style="color: #dc3545;">
                            <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                                <path d="M7.002 11a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 4.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 4.995z"/>
                            </svg>
                            Connection Failed
                        </div>
                        <div style="font-size: 12px; color: #dc3545; margin-top: 5px;">
                            ${result.error || 'Unknown error'}
                        </div>
                    `;
                    
                    // Update main status
                    const connStatus = document.getElementById('connStatus');
                    if (connStatus) {
                        connStatus.textContent = 'RTSP Connection Failed ✗';
                        connStatus.style.color = '#dc3545';
                    }
                }
            } catch (error) {
                statusEl.innerHTML = `
                    <div style="color: #dc3545;">
                        <svg width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path d="M7.002 11a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 4.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 4.995z"/>
                        </svg>
                        Detection Service Unavailable
                    </div>
                    <div style="font-size: 12px; color: #dc3545; margin-top: 5px;">
                        Cannot connect to detection service at http://127.0.0.1:5001
                    </div>
                `;
                
                // Update main status
                const connStatus = document.getElementById('connStatus');
                if (connStatus) {
                    connStatus.textContent = 'Detection Service Offline ✗';
                    connStatus.style.color = '#dc3545';
                }
            }
        }

        document.getElementById('btnPlay').addEventListener('click', async () => {
            const url = buildStreamUrl();
            showPreview(url);
            // If preview is image/video (not RTSP), send to detector API for first frame
            try {
                const payload = { source: url };
                // If using Demo (file:// object URL), snapshot the current image/video frame to base64
                const aiEl = document.getElementById('camera2-ai');
                if (aiEl && (aiEl.tagName === 'IMG' || aiEl.tagName === 'VIDEO')) {
                    const canvas = document.createElement('canvas');
                    const w = aiEl.clientWidth || 640; const h = aiEl.clientHeight || 360;
                    canvas.width = w; canvas.height = h; const c2d = canvas.getContext('2d');
                    try {
                        if (aiEl.tagName === 'IMG') {
                            c2d.drawImage(aiEl, 0, 0, w, h);
                            payload.imageData = canvas.toDataURL('image/jpeg');
                        } else if (aiEl.tagName === 'VIDEO' && aiEl.readyState >= 2) {
                            c2d.drawImage(aiEl, 0, 0, w, h);
                            payload.imageData = canvas.toDataURL('image/jpeg');
                        }
                    } catch {}
                }
                const resp = await fetch('http://127.0.0.1:5001/detect', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)});
                if (resp.ok) {
                    const result = await resp.json();
                    if (Array.isArray(result.detections)) {
                        renderDetections(2, result.detections, result.frameW, result.frameH);
                        if (typeof result.gaugePct === 'number') setGauge(2, result.gaugePct);
                    }
                }
            } catch {}
            // Schedule periodic detection updates for all active cameras
            if (window.__detInterval) clearInterval(window.__detInterval);
            window.__detInterval = setInterval(() => runDetectionFromCurrentMedia(), 2000);
        });
        document.getElementById('btnStop').addEventListener('click', () => {
            document.getElementById('connPreview').innerHTML = '';
            if (window.__detInterval) { clearInterval(window.__detInterval); window.__detInterval = null; }
            // Clear all detection canvases
            for (let i = 1; i <= 3; i++) {
                const canvas = document.getElementById(`det${i}`);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx && ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }
        });
        document.getElementById('btnClear').addEventListener('click', () => {
            ['ipAddress','port','channel','username','password','locName','latitude','longitude'].forEach(id => { const el = document.getElementById(id); if (el) el.value=''; });
            document.getElementById('connPreview').innerHTML = '';
        });

        // Add camera to next available slot and map
        let nextSlot = 1;
        document.getElementById('btnAddCamera').addEventListener('click', () => {
            if (nextSlot > 3) return closeConnections();
            const url = buildStreamUrl();
            const lat = parseFloat(document.getElementById('latitude').value);
            const lng = parseFloat(document.getElementById('longitude').value);
            const locName = (document.getElementById('locName').value || '').trim();
            if (!url || Number.isNaN(lat) || Number.isNaN(lng)) return;

            const slot = cameraSlots[nextSlot];
            document.getElementById(`section-${nextSlot}`).classList.remove('hidden');
            document.getElementById('no-cameras').classList.add('hidden');
            
            // Store camera URL for RTSP handling
            const cameraSection = document.getElementById(`section-${nextSlot}`);
            cameraSection.setAttribute('data-camera-url', url);
            cameraSection.setAttribute('data-camera-type', url.startsWith('rtsp://') ? 'rtsp' : 'http');
            
            // For RTSP streams, show placeholder initially and start streaming
            if (url.startsWith('rtsp://')) {
                const origImg = document.getElementById(slot.orig);
                const aiImg = document.getElementById(slot.ai);
                
                // Set placeholder images
                origImg.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQwIiBoZWlnaHQ9IjM2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjhmOWZhIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzZjNzU3ZCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkNvbm5lY3RpbmcgUlRTUC4uLjwvdGV4dD48L3N2Zz4=';
                aiImg.src = origImg.src;
                
                // Start RTSP streaming
                startRtspStreaming(nextSlot, url);
            } else {
                // For HTTP streams, set directly
                document.getElementById(slot.orig).src = url;
                document.getElementById(slot.ai).src = url;
            }
            
            setLastUpdate(slot.lu);

            // Update location header title with provided name
            const headerTitleEl = document.querySelector(`#section-${nextSlot} .panel-title`);
            if (headerTitleEl && locName) headerTitleEl.textContent = locName;

            // Initialize AI detection for this camera after a short delay
            setTimeout(() => {
                runDetectionFromCurrentMedia(nextSlot);
            }, 2000);

            // Add map marker to main map (MapLibre GL)
            if (map && map.loaded && map.loaded()) {
                const marker = new maplibregl.Marker({
                    color: '#FF0000'
                })
                .setLngLat([lng, lat])
                .setPopup(new maplibregl.Popup().setText(locName || `Camera ${nextSlot}`))
                .addTo(map);
                
                // Store marker reference
                cameraMarkers.push({
                    marker: marker,
                    slotNumber: nextSlot,
                    lat: lat,
                    lng: lng
                });
            }
            
            // Copy geofence from picker if exists
            if (drawnShape && pickerMap) {
                try {
                    let geoJson = null;
                    
                    if (drawnShape instanceof L.Circle) {
                        // Convert Leaflet circle to GeoJSON polygon
                        const center = drawnShape.getLatLng();
                        const radius = drawnShape.getRadius();
                        const points = [];
                        const numPoints = 32;
                        for (let i = 0; i < numPoints; i++) {
                            const angle = (i / numPoints) * 2 * Math.PI;
                            const dx = radius * Math.cos(angle) / 111320; // Approximate meters to degrees
                            const dy = radius * Math.sin(angle) / 110540;
                            points.push([center.lng + dx, center.lat + dy]);
                        }
                        points.push(points[0]); // Close the polygon
                        
                        geoJson = {
                            'type': 'Feature',
                            'geometry': {
                                'type': 'Polygon',
                                'coordinates': [points]
                            }
                        };
                    } else if (drawnShape instanceof L.Polygon) {
                        // Convert Leaflet polygon to GeoJSON
                        const latlngs = drawnShape.getLatLngs()[0];
                        const coordinates = latlngs.map(latlng => [latlng.lng, latlng.lat]);
                        coordinates.push(coordinates[0]); // Close the polygon
                        
                        geoJson = {
                            'type': 'Feature',
                            'geometry': {
                                'type': 'Polygon',
                                'coordinates': [coordinates]
                            }
                        };
                    }
                    
                    // Add to main map if we have valid GeoJSON
                    if (geoJson && map && map.loaded && map.loaded()) {
                        const sourceId = `geofence-${nextSlot}`;
                        const layerId = `geofence-layer-${nextSlot}`;
                        
                        map.addSource(sourceId, {
                            'type': 'geojson',
                            'data': geoJson
                        });
                        
                        map.addLayer({
                            'id': layerId,
                            'type': 'line',
                            'source': sourceId,
                            'paint': {
                                'line-color': '#2a8',
                                'line-width': 3
                            }
                        });
                    }
                } catch (error) {
                    console.error('Failed to copy geofence to main map:', error);
                }
            }
            
            nextSlot += 1;
            closeConnections();
        });

        // Settings Modal JavaScript
        let roboflowApiKey = 'FcbsUMiVOoBJ2B4GXYkl'; // Your API key
        
        // Settings modal functionality
        document.getElementById('menuSettings').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.remove('hidden');
        });
        
        document.getElementById('settingsClose').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.add('hidden');
        });
        
        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabId = btn.dataset.tab;
                
                // Update active tab button
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update active tab content
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(tabId + '-tab').classList.add('active');
            });
        });
        
        // Settings controls
        const confidenceSlider = document.getElementById('confidenceThreshold');
        const confidenceValue = document.getElementById('confidenceValue');
        
        confidenceSlider.addEventListener('input', () => {
            confidenceValue.textContent = confidenceSlider.value;
        });

        // Load project information
        async function loadRoboflowProject() {
            try {
                const response = await fetch('/api/roboflow/project', {
                    headers: {
                        'Authorization': `Bearer ${roboflowApiKey}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    updateRoboflowStats(data);
                } else {
                    console.error('Failed to load project:', response.statusText);
                    alert('Failed to load Roboflow project. Please check your API key.');
                }
            } catch (error) {
                console.error('Error loading project:', error);
                alert('Error connecting to Roboflow. Please try again.');
            }
        }

        // Update dashboard stats
        function updateRoboflowStats(projectData) {
            if (projectData.project) {
                document.getElementById('roboflow-images').textContent = projectData.project.images || 0;
                document.getElementById('roboflow-classes').textContent = projectData.project.classes?.join(', ') || 'N/A';
            }
            if (projectData.versions) {
                document.getElementById('roboflow-versions').textContent = projectData.versions.length || 0;
            }
        }

        // Download dataset
        async function downloadDataset() {
            const version = prompt('Enter version number to download:', '1');
            if (!version) return;

            try {
                const response = await fetch(`/api/roboflow/download/${version}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${roboflowApiKey}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.downloadLink) {
                        window.open(data.downloadLink, '_blank');
                    }
                } else {
                    alert('Failed to get download link. Please try again.');
                }
            } catch (error) {
                console.error('Error downloading dataset:', error);
                alert('Error downloading dataset. Please try again.');
            }
        }

        // Test inference
        async function testInference() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const version = prompt('Enter version number for inference:', '1');
                if (!version) return;

                const formData = new FormData();
                formData.append('image', file);

                try {
                    const response = await fetch(`/api/roboflow/inference/${version}?confidence=0.5`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${roboflowApiKey}`
                        },
                        body: formData
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        alert(`Inference complete! Found ${result.predictions?.length || 0} detections.`);
                        console.log('Inference result:', result);
                    } else {
                        alert('Failed to run inference. Please try again.');
                    }
                } catch (error) {
                    console.error('Error running inference:', error);
                    alert('Error running inference. Please try again.');
                }
            };
            input.click();
        }

        // Upload image to project
        async function uploadToRoboflow() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const name = prompt('Enter image name:', file.name);
                if (!name) return;

                const formData = new FormData();
                formData.append('image', file);

                try {
                    const response = await fetch(`/api/roboflow/upload?name=${encodeURIComponent(name)}&split=false`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${roboflowApiKey}`
                        },
                        body: formData
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            alert('Image uploaded successfully!');
                            loadRoboflowProject(); // Refresh stats
                        } else {
                            alert('Upload failed. Please try again.');
                        }
                    } else {
                        alert('Failed to upload image. Please try again.');
                    }
                } catch (error) {
                    console.error('Error uploading image:', error);
                    alert('Error uploading image. Please try again.');
                }
            };
            input.click();
        }

        // Event listeners for Roboflow buttons
        document.getElementById('btnLoadProject').addEventListener('click', loadRoboflowProject);
        document.getElementById('btnDownloadDataset').addEventListener('click', downloadDataset);
        document.getElementById('btnTestInference').addEventListener('click', testInference);
        document.getElementById('btnUploadImage').addEventListener('click', uploadToRoboflow);

        // Auto-load project when Settings modal opens
        document.getElementById('menuSettings').addEventListener('click', () => {
            setTimeout(loadRoboflowProject, 500); // Load after modal opens
        });
    </script>
}
